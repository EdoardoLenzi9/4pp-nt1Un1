\chapter{Automi a stati finiti}

Un NFA accetta/riconosce un certo linguaggio.

Sia N un NFA, allora il linguaggio riconosciuto/accettato da N \'e il set delle parole per le quali esiste almeno un cammino dallo stato iniziale di N ad uno stato finale di N.

notare che $\forall\ a \in A,\ a\varepsilon = \varepsilon a = a$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thompson construction}
\begin{center}
    \begin{tabular}{ll}
        input & regular expression r\\
        output & NFA N $\ / \ L(N) = L(r)$\\ 
    \end{tabular}
\end{center}
Gli NFA usati nei passi della costruzione hanno:
\begin{itemize}
    \item un solo stato finale\\ 
    \item non hanno archi entranti sul nodo iniziale\\ 
    \item non hanno archi uscenti dal nodo finale\\
\end{itemize}

\textbf{Lemma}: Lo NFA ottenuto dalle costruzini di Thompson ha al massimo 2k stati e 4k archi, con k lunghezza della re. r.
\textbf{Osservazione}: Ogni passo della costruzione introduce al massimo 2 nodi e 4 archi.

\begin{center}
	\includegraphics[scale=0.4]{Chapters/Img/c02_01.png}\\
\end{center} 
Algoritmo a complessit\'a $O(|r|)$ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simulare un NFA}
Il backtracking consiste nel seguire un percorso e se non va bene tornare in dietro e provarne un altro finch\'e alla fine 
li provo tutti mal che vada.

$N=(S,A,move_n,S_0,F)$, S insieme stati, A i non terminali (label degli archi), $S_0$ stato iniziale, F set stati finali, 
$move_n$ funzione di transizione ($S \otimes A \rightarrow S$)\\
$t \in S, T \subset S$\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\varepsilon -closure$}

\begin{tcolorbox}\begin{center}
    $\varepsilon - closure(\{ t \})$ il set degli stati S raggiungibili tramite \underline{zero o pi\'u} 
    $\varepsilon -transizioni$ da t (in pratica il nodo stesso e tutti i nodi raggiungibili con una $\varepsilon-transition$
    [\textbf{applicato ricorsivamente}]).
\end{center}\end{tcolorbox}

Nota che $\forall t \in S,\ t\in \varepsilon-closure(t) \qquad$ $\varepsilon-closure(T) = \cup _{t \in T} \varepsilon-closure(t)$\\

Questo algoritmo \'e pi\'u performante del backtracking.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algoritmo per la computazione $\varepsilon -closure$}
Strutture dati:
\begin{itemize}
    \item pila\\
    \item bool[] alreadyOn, dimensione $|S|$\\
    \item array[][] $move_n$\\ 
\end{itemize}
\begin{lstlisting}
    for(int i = 0; i < |S|; i++){
        alreadyOn[i] = false;
    }
    closure(t, stack){
        push t onto stack;
        alreadyOn[t] = true; //posso sempre arrivare a me stesso con una epsilon-transition 
        foreach(i in move_n(t, epsilon)){
            if(!alreadyOn[i]){
                closure(i, stack);
            }
        }
    }
\end{lstlisting}

\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_02.png}\\
\end{center} 

\begin{lstlisting}
    alredyOn[F F F F];
    closure(A, pila vuota)
        [A] [T F F F]
            //B non e' ancora nella pila
            closure(B, [A])
                [A, B] [T T F T]
                closure(D, [A, B])
                    [A, B, D] [T T F T]
            closure(C, [A, B, D])
                [A, B, C, D] [T T T T]
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algoritmo per la simulazione di un NFA}
\begin{center}
    \begin{tabular}{ll}
        input & NFA N, w$\$$\\
        output & yes se $w \in L(N)$, no altrimenti\\ 
    \end{tabular}
\end{center}
\begin{lstlisting}
    N = (S, A, move_n, S_0, F)
    states = epsilon-closure({S_0})
    symbol = nextchar()
    while(symbol != $){
        states = epsilon-closure(Unione_{t in states} di move_n(t, symbol));
        //l'insieme di tutti gli stati raggiungibili con la sottostringa letta fin ora
        symbol = nextchar();
    }
    if(states intersecato F != emptyset){
        return yes;
    }
    return no;
\end{lstlisting}

%TODO GRAFO PAGINA 17

Algoritmo a complessit\'a $O(|w|(n+m))$ 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{DFA}
Automa a stati finiti, deterministico; una sottoclasse degli NFA che rispettano:
\begin{center}
    DFA$\overset{\Delta}{=}(S,A,move_d,s_0,F)$  \\
    $move_d \overset{\Delta}{=} (S \otimes A) \rightarrow S$\\
\end{center}
\begin{itemize}
    \item non hanno $\varepsilon-transizioni$\\
    \item $\forall a \in A, s \in S,\ move_n(s,a)$ \'e un unico stato se ho una \textbf{funzione di transizione totale} 
    (al pi\'u uno stato se ho una \textbf{funzione di transizione parziale})\\
\end{itemize}
\begin{tcolorbox}\begin{center}
    \textbf{Sink} Ã¨ il nodo pozzo dove \textbf{confluiscono tutte le transizioni non segnate} 
    (per ogni stato se mi manca una transizione per un determinato terminale ne faccio una su sink);
    viene aggiunto per rendere la funzione di transizione una funzione di transizione totale
\end{center}\end{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Linguaggio riconosciuto dal DFA}
Dato il DFA D, L(D) \'e il linguaggio riconosciuto da D. \\
$L(D) = \{ w=a_1,...,a_k \ / \ \exists \text{ cammino in D dallo stato iniziale al finale}\}$.
$\varepsilon \in L(D) \iff s_0 \in F$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simulazione di un DFA con $move_d$ totale}
\begin{center}
    \begin{tabular}{ll}
        input & w$\$$, DFA $D=(S,A,move_d,F)$\\
        output & yes se $w \in L(D)$, no altrimenti\\
    \end{tabular}
\end{center}

\begin{lstlisting}
    state = s_0;
    while(symbol != $ && state != bottom){
        //move_d(s, a) = bottom <=> move_d non e' definita su (s,a)
        //se sono in bottom sono in sink
        state = move_d(state, symbol);
        symbol = newxtchar();
    }
    if(state \in F)
        return yes;
    return true;
\end{lstlisting}

Simulazione NFA costa $O(|w|(n+m))$
Simulazione DFA costa $O(|w|)$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subset Construction}
\begin{center}
    \begin{tabular}{ll}
        input & $NFA(S^n,A,move_n, S_0 ^n,F^n)$\\ 
        output & $DFA(S^d,A,move_d, S_0 ^d,F^d)$\\
    \end{tabular}
\end{center}

\begin{lstlisting}
	S_0^d = epsilon-closure({S_0^n});	
    //raggruppo stati della epsilon closure in un unico stato S_0^d del DFA
	states = {S_0^d};
	tag S_0^d come non marcato;

	while(exist T in states non marcato){
		marco T;
		foreach(a in A){ //guardo ogni arco
			T_1 = epsilon-closure(U_{t in T} di move_n(t,a));
            //tutti gli stati raggiungibili con una a-transition da uno stato in T 
            //poi la loro epsilon closure
			if(T_1 != emptySet){
				move_d(T, a) = T_1;
		 		if(T_1 !in states){
					aggiungi T_1 a states come non marcato;
				}
			}
		}
	}

	foreach(T in states){
		if( (T intersecato F^n) != 0){
			metti T in F^d;
		}
	}
\end{lstlisting}
Lo stato iniziale del DFA sar\'a la $\varepsilon - closure$ dallo stato iniziale del NFA (quindi un set di stati).
Considero lo stato iniziale del NFA e lo marco in grassetto poi espando $T_0$ con la $\varepsilon - closure$ dello stato iniziale. 

Dallo stato $T_0$ guardo per ogni arco gli stati in cui arrivo e li marco in grassetto ($T_1$, $T_2$, ...); 
poi espando quelli in grassetto guardando le rispettive $\varepsilon - closure$.

Alla fine guardo i set degli stati se due set coincidono mergio gli stati.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Esercizio}
\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_05.png}\\
\end{center} 

\begin{tabular}{lll}
    \textbf{States}                                 &   \textbf{a}        &     \textbf{b} \\
    T0 = $\{$ \textbf{A} B C E $\}$                 &   T1                &     T2  = T0\\
    T1 = $\{$ A B C \textbf{D E} $\}$               &   T1                &     T0 \\
    T2 = $\{$ \textbf{A} B C \textbf{E} $\}$ = T0 (quindi T0 va in T0 tramite b) & come T0 & come T0 \\
\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Esercizio}
\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_03.png}\\
\end{center} 

\begin{tabular}{lll}
    \textbf{States}                                 &   \textbf{a}        &     \textbf{b} \\
    $S_0^d = \{$ \textbf{0} 1 2 4 7 $\}$            &   T1                &     T2 \\
    T1 = $\{$ 1 2 \textbf{3} 4 6 7 \textbf{8} $\}$  &   T1                &     T3 \\
    T2 = $\{$ 1 2 4 \textbf{5} 6 7 $\}$             &   T1                &     T2 \\
    T3 = $\{$ 1 2 4 \textbf{5} 6 7 9 $\}$           &   T1                &     T4 \\
    T4 = $\{$ 1 2 4 \textbf{5} 6 7 \textbf{10} $\}$ &   T1                &     T2 \\
\end{tabular}

\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_04.png}\\
\end{center} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Partition Refinement}
\begin{tcolorbox}\begin{center}
    Guado gli archi, se tutta la partizione punta ad un nodo dell'altra transizione con lo stesso non terminale allora va bene; 
    altrimenti spacco la partizione.
\end{center}\end{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algoritmo di Partition Refinement}
\begin{center}
    \begin{tabular}{ll}
        Input   &   DFA D = $\{ A,A,move_d, s_0, F\}$\\
        Output  &   partizione di S in blocchi equidistanti\\ 
    \end{tabular}
\end{center}

\begin{lstlisting}
    B_1 = F;
    B_2 = S \ F;
    P = {B_1, B_2};
    while(exists B_i, B_j in P, exists a in A, B_i e'' partizionabile rispetto a (B_j, a)){
        sostituire B_i in P con split(B_i, (B_j, a));
    }
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Esempio}

\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_04.png}\\
\end{center} 

\begin{tabular}{ll}
    $\{$ A B C D $\}$ $\{$ E $\}$                       & Considero le partizioni dei terminali e non terminali \\  
    $\{$ A B C D $\}$ $\{$ E $\}$                       & Con a-transizione non esco dal primo set\\  
    $\{$ A B C $\}$ $\{$ D $\}$ $\{$ E $\}$             & Con b-transizione vado da D in E (e A B C non vanno in E con b-transizioni)\\  
    $\{$ A B C $\}$ $\{$ D $\}$ $\{$ E $\}$             & Con a-transizione non esco\\    
    $\{$ A C $\}$ $\{$ B $\}$ $\{$ D $\}$ $\{$ E $\}$   & Con b-transizione vado da B in D e gli altri no quindi splitto \\
    $\{$ A C $\}$ $\{$ B $\}$ $\{$ D $\}$ $\{$ E $\}$   & vanno bene \\
\end{tabular}\\[5pt]

Rinomino  $\{$ A C $\}$ $\{$ B $\}$ $\{$ D $\}$ $\{$ E $\}$ in $t_1,\ t_2,\ t_3,\ t_4 $

\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_06.png}\\
\end{center} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algoritmo di minimizzazione di DFA}
\begin{center}
    \begin{tabular}{ll}
        Input   &   DFA \textbf{D} = $\{ S,A,move_d, s_0, F\}$ con $move_d$ totale\\
        Output  &   minimo DFA (\textbf{min(D)}) che riconosce lo stesso linguaggio del primo\\ 
    \end{tabular}
\end{center}

\begin{lstlisting}
    P = PartitionRefinement(DFA D);
    // P = (B_1, ..., B_k);
    foreach(B_i in P){
        var t_i;            //do un nome alla partizione
        if(s_o in B_i){
            t_i e'' iniziale per min(D);    //setto lo stato iniziale di min(D)
        }
    }

    foreach(B_i in P, B_i in F){
        t_i e'' lo stato finale di min(D);  //setto lo stato finale di min(D)
    }

    foreach( (B_i, a, B_j) tale che esiste s_i in B_i tali che move_d(s_i, a) = s_j){
        //per ogni tupla (stato, arco, stato) faccio la rispettiva transizione in min(D)
        setto una transizione temporanea in min(D) da t_i a t_j secondo il simbolo a;
    }

    foreach(dead state t_i){
        rimuovere t_i e tutte le transizioni da/verso t_i;
    }
    tutti i temporanei residui (sia stati che transizioni) sono gli stati e le transizioni di min(D);
\end{lstlisting}
Complessit\'a $O(nlgn)$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\subsection{Esempio}

\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_06.png}\\
\end{center} 
Arrivato qua: rinominati $\{$ A C $\}$ $\{$ B $\}$ $\{$ D $\}$ $\{$ E $\}$ in $t_1,\ t_2,\ t_3,\ t_4 $,
applico la minimizzazione del DFA.

\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_07.png}\\
\end{center} 

Ho le partizioni $\{A,\ B\}$, $\{C,\ sink\}$, applico partition refinement ma sono gi\'a partizionati correttamente.

\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_08.png}\\
\end{center} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\subsection{Esempio}
Sia $r=(a|b)*a(a|b)(a|b)$, per determinare il minimo DFA di riconoscimento di L(r) posso usare Thompson e spararmi in faccia o andare
a naso.

\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_09.png}\\
\end{center} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\subsection{Lemma}
Lemma: $\forall n \in \mathbb{N}^+,\ \exists\ $ un NFA con (n+1) stati il cui minimo DFA equivalente ha almeno $2^n$ stati.\\

Dim: 
\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_10.png}\\
\end{center} 

Per assurdo suppongo esista un DFA minimo con meno di $2^n$ stati.\\
Osservo che esistono $2^n$ possibili parole di lunghezza n con simboli $\{ a, b\}$.\\
$\implies \exists\ w_1 \not = w_2 \ / \ |w_1| = |w_2| = n $ e il loro riconoscimento conduce allo stesso stato del DFA.\\
$\implies$ esiste almeno una posizione per cui $w_1 \ e\ w_2$ differiscono (considero quella pi\'u a destra).\\

$w_1 = w_1'ax$, $w_2 = w_2'bx$ iniziano diversi ma finiscono con x entrambe.
Considero $w_1'' = w_1'ab^{n-1}$ $w_2'' = w_2'bb^{n-1}$ raggiungo uno stato finale t; la seconda parola per\'o non appartiene al 
linguaggio, nonostante possa comunque raggiungere lo stato t. Pertanto contraddiciamo che t sia finale.
%TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{Ricapitolando}
\begin{center}
	\includegraphics[scale=0.5]{Chapters/Img/c02_11.png}\\
\end{center} 

\begin{tabular}{|l|l|l|}
\hline
Algoritmo   &   Complessit\'a nello spazio  &   Complessit\'a nel tempo\\
\hline
Thompson Construction   &   $O(|r|)$    &   $O(|r|)\ ||\ O(n_n+m_n)$\\
Simulazione NFA         &   -           &   $O(|w|(n_n+m_n))$       \\
Subset Construction     &   -           &   $O(n_d |A| (n_n + m_n))$\\
Minimazzazione DFA      &   -           &   $O(n_d lg(n_d))$        \\
Simulazione DFA         &   -           &   $O(|w|)$                \\
\hline
\end{tabular}